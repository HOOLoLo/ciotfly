#ifndef GET_LIGHT_H#define GET_LIGHT_H#include <opencv2/core/core.hpp>  #include <opencv2/imgproc/imgproc.hpp>  #include <opencv2/highgui/highgui.hpp>#include<opencv2/highgui/highgui_c.h>#include <iostream>#include <sys/types.h>#include <sys/socket.h>#include<pthread.h>#include <netinet/in.h>#include <arpa/inet.h>#include <stdio.h>#include <string.h>#include <unistd.h>#include <stdlib.h>#include <fstream>#include <time.h>#define pi 3.1415926 #define err 404using namespace std;using namespace cv;double cal_y_theta(Point2i head, Point2i tail);//列向遍历void find_col_head_tail(int i, Mat srcImage, int &head, int &tail, int threshold);int col_search(Mat srcImage, int startcol, int endcol, Point2i &head_full, Point2i &tail_full, int mthreshold);//列向遍历的出的theta角double Col_Search_theta(Mat &srcImage, int mthreshold, Point2i &tophead, Point2i &toptail, Point2i &bottomhead, Point2i &bottomtail, Point2i &top, Point2i &bottom);//计算角度函数double cal_theta(Point2i head, Point2i tail);//找一行的首末点void find_Head_Tail(uchar *p, int nCols, int &head, int &tail);//得出theta角double find_true_theta(Mat &srcImage, int mthreshold, Point2i &tophead, Point2i &toptail, Point2i &bottomhead, Point2i &bottomtail, Point2i &top, Point2i &bottom);void find_cross_line(Point2i top, Point2i bottom, int cols, int rows, Point2i edgePoint[]);//one color inrangevoid inrange(Mat _src, uchar _low[3], uchar _up[3], Mat _dst);//void inrange(Mat _src, uchar _low[3], uchar _up[3], uchar _low_change[3], uchar _up_change[3], Mat _dst, Mat _dst_change);//查表法inrangevoid inrange_lut(Mat _src, const uchar _table1[], const uchar _table2[], const uchar _table3[], Mat _dst);void createTable(uchar _low[3], uchar _up[3], uchar _table1[], uchar _table2[], uchar _table3[]);Point2i find_core(Point2i top, Point2i bottom, int cols, int rows);void inrange_c(Mat _src, uchar _low[3], uchar _up[3], Mat _dst);#endif
